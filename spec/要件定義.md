アイデアのもと:https://arxiv.org/html/2507.19550v1

## 1. プロダクト概要

### 1.1 目的

A2A、x402、ブロックチェーンを融合した AI エージェント向け分散型マーケットプレイス。エージェントが自律的に他のエージェントを発見・利用・決済できるエコシステムを実現する。

### 1.2 コアバリュー

- **Discovery（発見）**: オンチェーンでエージェントを検索・発見
- **Trust（信頼）**: ブロックチェーンベースの評価システム
- **Automation（自動化）**: x402 による人間介入不要の決済
- **Openness（開放性）**: フレームワーク非依存の標準準拠

---

## 2. システム構成

### 2.1 技術スタック

| レイヤー         | 技術                          | 役割                         |
| ---------------- | ----------------------------- | ---------------------------- |
| ブロックチェーン | Solidity, ETH Sepolia         | レジストリ、評価管理         |
| エージェント実行 | Claude API + MCP (fastMCP)    | ユーザーエージェント         |
| バックエンド     | Next.js, ethers.js, Privy SDK | MCP Tools実装, Discovery API |
| フロントエンド   | Next.js, Privy                | UI、ウォレット管理           |
| 決済             | x402, USDC                    | 自動マイクロペイメント       |

### 2.2 アーキテクチャ

```mermaid
graph TB
    User[ユーザー] -->|Privy認証| UI[Web UI]
    UI -->|ウォレット作成| Privy[Privy]
    User -->|チャットで指示| Claude[Claude API]

    Claude -->|MCP| MCP[MCP Host]
    MCP -->|execute_agent_capability| ExtAgent[外部エージェント]
    ExtAgent -->|HTTP 402| MCP
    MCP -->|自動決済| Privy
    Privy -->|署名| MCP
    MCP -->|決済後再送| ExtAgent
    MCP -->|discover_agents| BC[Blockchain]
    BC -->|AgentCard返却(価格含む)| MCP
    MCP -->|record_transaction| BC
    Claude -->|結果表示| User
```

### 2.3 LLM と MCP Host の責務分離

**LLM（Claude API）の役割**:

- タスク分解と計画立案
- 利用するエージェントの選択
- **価格情報に基づく決済判断（maxPrice設定）**
- ユーザー予算との整合性確認

**MCP Host の責務**:

- Agent endpoint への実際の呼び出し
- x402 決済プロトコルの実行
- **maxPrice範囲内での自動決済**
- 決済後の自動再送
- Privy を介した署名生成
- オンチェーンへの記録

**重要原則**: Claude は `discover_agents` で取得した価格情報を基に決済の可否を判断し、`maxPrice` パラメータで許容上限を設定する。MCP Host は HTTP 402 受信時に `maxPrice` と実際の請求額を比較し、範囲内であれば自動決済・再送を実行する。Claude は x402 プロトコルの詳細（署名作成・再送ロジック）を認識せず、決済の「判断」のみを担当する。

---

## 3. 主要機能

### 3.1 ユーザー認証・ウォレット管理

**概要**: Privy によるソーシャルログインとウォレット自動作成

**機能**:

- ソーシャルログイン（Google、Email）
- ウォレット自動作成（秘密鍵は Privy 管理）
- USDC 入金・approve実行
- 予算上限設定

**画面**:

- ログイン画面
- ウォレット作成・入金画面
- 予算設定画面

---

### 3.2 ユーザーエージェント（Claude + MCP）

**概要**: Claude APIがMCP Toolsを使用してエージェントとして機能

**実装方式**:

- **エージェント本体**: Claude API（推論・判断・タスク計画・価格判断）
- **実行レイヤー**: MCP Host（fastMCP実装）
  - `discover_agents`: ブロックチェーン検索（価格情報含む）
  - `execute_agent_capability`: エージェント機能の実行（A2A呼び出し、maxPrice範囲内でのx402決済、再送を完結）
  - `record_transaction`: オンチェーン記録

**エージェントの動作**:

1. ユーザーから自然言語で指示を受け取る
2. Claude APIがタスクを分解・計画
3. MCP Toolsを呼び出して実行（価格情報取得→判断→実行）
4. 結果を統合して自然言語で返却

**MCP Tools詳細**:

```typescript
// discover_agents Tool
- 機能: ethers.jsでブロックチェーンからAgentCard検索
- 入力: category, maxPrice, minReputation
- 出力: AgentCard配列（価格情報含む）
  例: [{ name: "FlightAgent", price: 0.01, url: "...", rating: 4.5 }]

// execute_agent_capability Tool
- 機能: エージェント機能の実行（A2A + x402 + 再送を内部で完結）
- 入力: agentUrl, message, userId, maxPrice
- 内部処理:
  1. A2A JSON-RPC呼び出し（fetch）
  2. HTTP 402受信時、請求額とmaxPriceを比較
  3. 範囲内の場合: Privyウォレット取得
  4. EIP-3009署名作成
  5. X-PAYMENTヘッダー構築
  6. 決済付きA2A再送（自動）
  7. 範囲外の場合: エラー返却
- 出力: エージェント応答, txHash, 実際の決済額

// record_transaction Tool
- 機能: ethers.jsでオンチェーン記録
- 入力: agentId, amount, userId
- 出力: txHash
```

**PoC制限**: ユーザー独自のエージェントエンドポイント登録は未対応

---

### 3.3 外部エージェント（サービス提供側）

**概要**: マーケットプレイスで発見されるエージェント

**要件**:

- オンチェーンにAgentCard登録（価格情報含む）
- A2Aプロトコル実装
- x402対応（HTTP 402 + 決済処理）
- ADKで実装（サンプル2-3個）

---

### 3.4 エージェント検索・発見

**概要**: 必要な機能を持つエージェントをマーケットプレイスから検索

**検索方法**:

- **ユーザー向け**: Web UIのマーケットプレイス画面（Discovery API経由）
- **Claude（エージェント）向け**: MCP Tool `discover_agents`

**検索条件**:

- キーワード
- カテゴリ
- 価格範囲
- 評価スコア

**表示項目**:

- エージェント名
- **価格（USDC）**
- 評価スコア（5段階評価の平均）
- 総利用回数

---

### 3.5 エージェント実行フロー

```mermaid
sequenceDiagram
    participant U as ユーザー
    participant UI as Web UI (チャット)
    participant C as Claude API
    participant MCP as MCP Host
    participant BC as Blockchain
    participant EA as 外部エージェント
    participant P as Privy

    U->>UI: Privyでログイン
    U->>UI: 「パリ3日間の旅行プラン作成」
    UI->>C: 指示を送信

    C->>C: タスク分解・計画

    C->>MCP: discover_agents(category="travel")
    MCP->>BC: ethers.jsでクエリ
    BC-->>MCP: AgentCard一覧（価格含む）
    MCP-->>C: AgentCard一覧

    C->>C: 価格確認・予算チェック
    C->>C: 最適エージェント選択（価格考慮）

    loop 各エージェント
        C->>MCP: execute_agent_capability(agentUrl, message, userId, maxPrice)

        Note over MCP: 以下はMCP Host内部処理
        MCP->>EA: A2A JSON-RPC
        EA-->>MCP: HTTP 402 + paymentInfo
        MCP->>MCP: maxPriceチェック

        alt 価格が範囲内
            MCP->>P: getPrivyWallet(userId)
            P-->>MCP: wallet
            MCP->>MCP: EIP-3009署名作成
            MCP->>EA: X-PAYMENT付きで自動再送
            EA-->>MCP: 結果返却
            MCP-->>C: 結果 + txHash + 決済額
        else 価格が範囲外
            MCP-->>C: エラー（価格超過）
        end

        C->>MCP: record_transaction(agentId, amount, userId)
        MCP->>BC: オンチェーン記録
        BC-->>MCP: txHash
        MCP-->>C: 記録完了
    end

    C->>C: 結果統合
    C->>UI: 統合プラン表示
    UI->>U: 旅行プラン提示

    U->>UI: 5段階評価入力
    UI->>BC: 評価をオンチェーン記録
```

**ユーザー操作**:

1. Privyでログイン
2. ウォレットにUSDC入金（事前approve実行）
3. 予算設定（日次上限、自動承認閾値）
4. チャット画面で指示を入力（例: 「パリ3日間の旅行プラン作成」）
5. Claudeエージェントが自動実行（MCP Tools経由、価格判断含む）
6. 統合結果を自然言語で表示
7. 5段階評価を入力

---

### 3.6 x402 決済

**前提条件**: 全登録エージェントは x402 対応済み

**決済フロー（MCP Host内部処理）**:

1. Claude → `execute_agent_capability` Tool呼び出し（maxPrice指定）
2. MCP Host内部:
   - 外部エージェントにA2Aリクエスト
   - HTTP 402 + paymentInfo受信
   - **請求額とmaxPriceを比較**
   - 範囲内の場合:
     - Privyウォレット取得
     - EIP-3009署名作成
     - X-PAYMENTヘッダー構築
     - 決済付きA2A再送（自動）
     - 決済検証・実行
     - 結果受信
   - 範囲外の場合: エラー返却
3. MCP Host → Claudeに結果返却
4. Claude → `record_transaction` Tool呼び出し

**決済判断ロジック**:

```typescript
// Claudeの判断（discover_agents結果から）
const flightAgent = agents.find((a) => a.category === 'flight');
if (flightAgent.price <= userBudget && flightAgent.price <= dailyLimit) {
  // maxPriceを設定して実行
  await execute_agent_capability({
    agentUrl: flightAgent.url,
    message: 'パリ行きの航空券',
    maxPrice: flightAgent.price, // Claudeの判断
  });
}

// MCP Host内部（402受信時）
if (paymentInfo.amount <= maxPrice) {
  // 自動決済
} else {
  throw new Error(`Price ${paymentInfo.amount} exceeds maxPrice ${maxPrice}`);
}
```

**決済情報**:

- 決済額（USDC）
- 決済元/先アドレス
- タイムスタンプ
- トランザクションハッシュ

---

### 3.7 レピュテーションシステム

**評価方式**: PoCでは5段階評価（1-5）の平均値

**計算方法**:

```
平均評価 = 総評価点数 ÷ 評価回数
例: (5 + 4 + 5 + 3) ÷ 4 = 4.25
```

**評価フロー**:

1. エージェント実行完了後、ユーザーがUI画面で1-5の評価を入力
2. フロントエンド → バックエンドAPI経由でオンチェーン記録
3. スマートコントラクトが自動で平均値を更新

**記録タイミング**: トランザクション完了後、ユーザーが評価入力時

**表示場所**:

- マーケットプレイス一覧
- エージェント詳細画面
- トランザクション履歴

---

## 4. 画面定義

### 4.1 画面一覧

| 画面名               | 主要機能                                                   |
| -------------------- | ---------------------------------------------------------- |
| ログイン             | Privy 認証                                                 |
| ウォレット作成・入金 | USDC 入金、approve実行、アドレス表示                       |
| 予算設定             | 日次上限、自動承認閾値設定                                 |
| チャット画面         | 指示入力、実行ログ表示（Claude + MCP）、結果表示、評価入力 |
| マーケットプレイス   | 検索、一覧、詳細表示、評価スコア・価格表示                 |
| トランザクション履歴 | 決済一覧、評価履歴、統計グラフ                             |

---

## 5. データ定義

### 5.1 エージェント情報（オンチェーン）

```solidity
struct Skill {
    string id;
    string name;
    string description;
}

struct PaymentInfo {
    address tokenAddress;      // USDC contract address
    address receiverAddress;   // エージェントの受取アドレス
    uint256 pricePerCall;      // 1回あたりの価格（6 decimals）
    string chain;              // "sepolia"
}

struct AgentCard {
    // === A2A標準フィールド ===
    bytes32 agentId;
    string name;
    string description;
    string url;                // A2Aエンドポイント
    string version;
    string[] defaultInputModes;
    string[] defaultOutputModes;
    Skill[] skills;

    // === ブロックチェーン拡張 ===
    address owner;
    bool isActive;
    uint256 createdAt;

    // === 評価システム（5段階評価の平均） ===
    uint256 totalRatings;      // 評価の合計（例: 5+4+5 = 14）
    uint256 ratingCount;       // 評価回数（例: 3回）
    // 平均評価 = totalRatings / ratingCount

    // === x402決済情報 ===
    PaymentInfo payment;

    // === カテゴリ ===
    string category;
}
```

### 5.2 トランザクション記録（オンチェーン）

```solidity
struct Transaction {
    bytes32 txId;
    bytes32 agentId;
    address caller;
    uint8 rating;              // ユーザー評価（1-5）
    uint256 amount;            // 支払額
    uint256 timestamp;
}
```

---

## 6. 外部連携仕様

### 6.1 A2A プロトコル準拠

**エージェント提供者の要件**:

- `.well-known/agent.json` 提供
- A2Aエンドポイント実装
- JSON-RPC 2.0 対応
- HTTPS 通信

### 6.2 x402 プロトコル準拠

**エージェント提供者の要件**:

- HTTP 402 ステータスコード返却
- x402 ヘッダー提供
- USDC（ETH）決済受付
- EIP-3009対応
- Coinbase x402 SDK 使用推奨

### 6.3 Claude API

**使用モデル**: Claude Sonnet 4

**Tool Use機能**: MCP Tools呼び出しに使用

**API Key管理**: 環境変数で保護

---

## 7. 非機能要件

### 7.1 パフォーマンス

- エージェント検索: 1 秒以内
- x402 決済完了: 3 秒以内（MCP Host内部処理）
- レピュテーション更新: 3 秒以内
- Claude API応答: 5-10 秒以内（Tool呼び出し含む）
- MCP Tool実行: 2-5 秒以内/Tool（決済含む）

### 7.2 セキュリティ

- Privy による秘密鍵管理
- HTTPS 通信必須
- ウォレットアドレス検証
- Claude API Key保護（環境変数）
- MCP Tools実行時のユーザー認証
- **maxPrice範囲外の決済を自動拒否**

### 7.3 スケーラビリティ（PoC）

- 登録エージェント数: 10件程度
- 同時実行ユーザー: 10 人
- 1ユーザーあたりClaude API呼び出し: Tool Use形式で2-3回/タスク
- 1タスクあたりMCP Tool呼び出し: 3-5回

---

## 8. PoC スコープ

### 8.1 含む機能

- ✅ スマートコントラクト（登録・検索・評価・価格情報）
- ✅ Discovery API（マーケットプレイス用）
- ✅ Privy 統合
- ✅ **MCP Host実装（fastMCP）**
  - ✅ discover_agents（価格情報含む）
  - ✅ execute_agent_capability（A2A + maxPrice範囲内でのx402 + 再送を内包）
  - ✅ record_transaction
- ✅ Claude API統合（Tool Use、価格判断含む）
- ✅ x402 決済フロー（MCP Host内部処理、maxPrice検証含む）
- ✅ サンプルエージェント 2-3 個（ADK、価格設定含む）
- ✅ Web UI（6 画面、チャット含む）
- ✅ CLI ツール（エージェント登録用）

### 8.2 含まない機能

- ❌ Claude Desktop統合（Claude APIで実装）
- ❌ DAO ガバナンス
- ❌ 紛争解決システム
- ❌ AIレコメンデーション
- ❌ モバイルアプリ
- ❌ マルチチェーン対応
- ❌ ユーザー独自エージェントのエンドポイント登録

---

## 9. 開発ステップ

### Step 1: ブロックチェーン基盤

- スマートコントラクト実装（AgentCard, Transaction, 評価システム、価格情報）
- Sepolia デプロイ
- テスト

### Step 2: MCP Host基盤

- Next.js セットアップ
- fastMCP導入
- MCP Tools実装
  - discover_agents（ethers.js、価格情報取得）
  - execute_agent_capability（fetch + Privy SDK統合 + maxPrice検証）
  - record_transaction（ethers.js）

### Step 3: ウォレット & 認証

- Privy 統合
- ログイン画面
- ウォレット作成・入金画面
- 予算設定機能実装
- MCP HostからのPrivy連携実装

### Step 4: Claude API統合

- Tool Use実装
- MCP Tools呼び出しフロー
- 価格判断ロジック実装
- エラーハンドリング

### Step 5: チャットUI

- チャット画面実装
- Claude API呼び出し
- 実行ログ表示（Tool呼び出し履歴、価格判断含む）
- 評価入力機能

### Step 6: Discovery API

- オンチェーン連携（ethers.js）
- 検索機能（価格フィルタ含む）
- キャッシュ実装

### Step 7: サンプルエージェント

- ADK で作成（Flight, Hotel, Tourism）
- x402 実装
- 価格設定
- オンチェーン登録

### Step 8: マーケットプレイス & 履歴

- マーケットプレイス画面（価格表示含む）
- トランザクション履歴画面
- 統計グラフ

### Step 9: デモ準備

- 統合テスト
- デモシナリオ検証
- ドキュメント

---

## 10. デモシナリオ

**目標**: 「パリ 3 日間の旅行プラン」と入力し、Claudeエージェントが自動で航空券・ホテル・観光エージェントを発見・価格確認・利用し、統合プランを提示

**フロー**:

1. ユーザーが Privy でログイン
2. 10 USDC 入金・approve実行
3. 予算設定: 日次上限 $5、自動承認閾値 $0.10
4. チャット画面で「パリ 3 日間の旅行プラン」と入力
5. Claudeエージェントが自動実行:
   - タスク分解: 「フライト・ホテル・観光が必要」
   - [MCP: discover_agents] 全AgentCard取得（価格情報含む）
   - 価格確認: FlightAgent ($0.01), HotelAgent ($0.02), TourismAgent ($0.01)
   - 予算チェック: 合計 $0.04 < 日次上限 $5 → OK
   - エージェント選択: FlightAgent, HotelAgent, TourismAgent
   - [MCP: execute_agent_capability] FlightAgent実行（maxPrice: 0.01）
     - 内部でA2A呼び出し、HTTP 402受信
     - 請求額 $0.01 <= maxPrice $0.01 → OK
     - Privy署名、決済、再送を完結
   - [MCP: record_transaction] オンチェーン記録
   - （ホテル・観光も同様に実行）
   - 結果統合
6. 統合プラン表示（自然言語 + 費用明細）
7. ユーザーが5段階評価入力
8. 全取引・評価がオンチェーン記録

**実行ログ表示例**:

```
[Claude] タスクを分析中...
[MCP: discover_agents] カテゴリ「travel」で検索中...
[MCP: discover_agents] 3件のエージェントを発見
[Claude] 価格確認: FlightAgent $0.01, HotelAgent $0.02, TourismAgent $0.01
[Claude] 合計予算 $0.04 < 日次上限 $5 → 実行可能
[Claude] FlightAgent（評価4.5, $0.01）を選択
[MCP: execute_agent_capability] FlightAgentを実行中（maxPrice: $0.01）...
[MCP: execute_agent_capability] 請求額 $0.01 確認、決済実行中...
[MCP: execute_agent_capability] 決済完了（tx: 0x1234...）
[MCP: record_transaction] オンチェーン記録完了
[Claude] フライト情報を取得しました（費用: $0.01）
...
[Claude] 旅行プランを作成しました! 総費用: $0.04
```

---

## 11. ER図

```mermaid
erDiagram
    users ||--o| budget_settings : has
    users ||--o{ transactions : makes
    users ||--o{ agent_ratings : gives
    users ||--o{ mcp_sessions : creates

    users {
        UUID id PK
        VARCHAR privy_user_id UK
        VARCHAR wallet_address UK
        TIMESTAMP created_at
    }

    budget_settings {
        UUID user_id PK
        DECIMAL daily_limit
        DECIMAL auto_approve_threshold
        TIMESTAMP created_at
    }

    transactions {
        UUID id PK
        UUID user_id FK
        VARCHAR agent_id
        DECIMAL amount
        VARCHAR tx_hash UK
        VARCHAR status
        TIMESTAMP created_at
    }

    agent_ratings {
        UUID id PK
        UUID user_id FK
        VARCHAR agent_id
        INT rating "1-5"
        VARCHAR tx_hash FK
        TIMESTAMP created_at
    }

    mcp_sessions {
        UUID id PK
        UUID user_id FK
        TEXT user_instruction
        JSON tool_calls "MCP Tool呼び出し履歴"
        DECIMAL total_cost
        VARCHAR status "running/completed/failed"
        TIMESTAMP started_at
        TIMESTAMP completed_at
    }
```

**テーブル説明**:

- `users`: Privyユーザー情報
- `budget_settings`: 予算上限設定
- `transactions`: オフチェーントランザクション参照（tx_hashでオンチェーンを参照）
- `agent_ratings`: 評価記録（オンチェーンのTransactionを参照）
- `agent_cache`: AgentCardのキャッシュ（Discovery API用、パフォーマンス向上）
- `mcp_sessions`: MCP実行セッション履歴（デバッグ・監査用）

**注**: 評価・トランザクションの実体はオンチェーン。オフチェーンDBは参照・キャッシュのみ。

---

## 12. MCP Tools仕様詳細

### 12.1 discover_agents

```typescript
{
  name: "discover_agents",
  description: "ブロックチェーンからAgentCard（価格情報含む）を検索",
  inputSchema: {
    type: "object",
    properties: {
      category: { type: "string", description: "カテゴリ" },
      maxPrice: { type: "number", description: "最大価格（検索フィルタ）" },
      minReputation: { type: "number", description: "最小評価" }
    }
  },
  handler: async ({ category, maxPrice, minReputation }) => {
    const registry = new ethers.Contract(REGISTRY_ADDRESS, ABI, provider);
    const agents = await registry.getAgentsByCategory(category);

    // フィルタリング・整形（価格情報を含める）
    const filteredAgents = agents
      .filter(a => a.payment.pricePerCall <= maxPrice && a.averageRating >= minReputation)
      .map(a => ({
        agentId: a.agentId,
        name: a.name,
        description: a.description,
        url: a.url,
        price: ethers.formatUnits(a.payment.pricePerCall, 6), // USDC 6 decimals
        rating: a.totalRatings / a.ratingCount,
        category: a.category
      }));

    return { agents: filteredAgents };
  }
}
```

### 12.2 execute_agent_capability

```typescript
{
  name: "execute_agent_capability",
  description: "エージェント機能の実行（A2A + maxPrice範囲内でのx402決済 + 再送を内部で完結）",
  inputSchema: {
    type: "object",
    properties: {
      agentUrl: { type: "string", description: "エージェントのURL" },
      message: { type: "string", description: "送信メッセージ" },
      userId: { type: "string", description: "ユーザーID" },
      maxPrice: { type: "number", description: "許容する最大価格（USDC）" }
    },
    required: ["agentUrl", "message", "userId", "maxPrice"]
  },
  handler: async ({ agentUrl, message, userId, maxPrice }) => {
    // 1. 初回A2Aリクエスト
    const initialResponse = await fetch(agentUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "message/send",
        params: { message }
      })
    });

    // 2. HTTP 402の場合、maxPriceチェックと自動決済処理
    if (initialResponse.status === 402) {
      const paymentInfo = await initialResponse.json();
      const requestedAmount = parseFloat(paymentInfo.amount);

      // maxPriceチェック
      if (requestedAmount > maxPrice) {
        throw new Error(
          `Payment required: $${requestedAmount} exceeds maxPrice $${maxPrice}`
        );
      }

      // Privyウォレット取得
      const wallet = await getPrivyWallet(userId);

      // EIP-3009署名作成
      const domain = {
        name: "USD Coin",
        version: "2",
        chainId: paymentInfo.chainId,
        verifyingContract: paymentInfo.tokenAddress
      };
      const types = {
        TransferWithAuthorization: [
          { name: "from", type: "address" },
          { name: "to", type: "address" },
          { name: "value", type: "uint256" },
          { name: "validAfter", type: "uint256" },
          { name: "validBefore", type: "uint256" },
          { name: "nonce", type: "bytes32" }
        ]
      };
      const value = {
        from: wallet.address,
        to: paymentInfo.receiver,
        value: ethers.parseUnits(paymentInfo.amount, 6),
        validAfter: 0,
        validBefore: Math.floor(Date.now() / 1000) + 3600,
        nonce: ethers.hexlify(ethers.randomBytes(32))
      };

      const signature = await wallet.signTypedData(domain, types, value);

      // X-PAYMENTヘッダー構築
      const payment = {
        from: wallet.address,
        to: paymentInfo.receiver,
        value: paymentInfo.amount,
        validAfter: value.validAfter,
        validBefore: value.validBefore,
        nonce: value.nonce,
        signature,
        v: signature.v,
        r: signature.r,
        s: signature.s
      };
      const paymentBase64 = Buffer.from(JSON.stringify(payment)).toString('base64');

      // 3. 決済付きで自動再送
      const retryResponse = await fetch(agentUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-PAYMENT": paymentBase64
        },
        body: JSON.stringify({
          jsonrpc: "2.0",
          method: "message/send",
          params: { message }
        })
      });

      const paymentResponseHeader = retryResponse.headers.get("X-PAYMENT-RESPONSE");
      const txHash = paymentResponseHeader
        ? JSON.parse(Buffer.from(paymentResponseHeader, 'base64').toString()).txHash
        : null;

      return {
        status: "success",
        result: await retryResponse.json(),
        txHash,
        amount: requestedAmount
      };
    }

    // 決済不要の場合はそのまま返却
    return {
      status: "success",
      result: await initialResponse.json(),
      amount: 0
    };
  }
}
```

### 12.3 record_transaction

```typescript
{
  name: "record_transaction",
  description: "トランザクションをオンチェーン記録",
  inputSchema: {
    type: "object",
    properties: {
      agentId: { type: "string", description: "エージェントID" },
      amount: { type: "number", description: "決済額（USDC）" },
      userId: { type: "string", description: "ユーザーID" }
    },
    required: ["agentId", "amount", "userId"]
  },
  handler: async ({ agentId, amount, userId }) => {
    const wallet = await getPrivyWallet(userId);
    const registry = new ethers.Contract(REGISTRY_ADDRESS, ABI, wallet);

    // rating=0（評価は後でユーザーが入力）
    const amountInWei = ethers.parseUnits(amount.toString(), 6); // USDC 6 decimals
    const tx = await registry.recordTransaction(agentId, 0, amountInWei);
    await tx.wait();

    return {
      status: "success",
      txHash: tx.hash
    };
  }
}
```
